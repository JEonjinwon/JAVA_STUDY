package f_OOP2;

public class OOP2_Basic {

	public static void main(String[] args) {
		/*
		1. 상속(~~은 ~~이다.) : is a
			- 기존의 클래스를 재사용하여 새로운 클래스를 만든다.
			- 적은양의 코드로 새로운 클래스를 작성할 수 있다.
			- 새로 작성하고자 하는 클래스의 뒤에 상속 받고자 하는 클래스를 키워드 'extends'와 함께 써주기만 하면 된다.
				class Child extends Parents {
				}
			- 상속을 해주는 클래스를 '조상클래스' 상속을 받는 클래스를 '자손클래스'라고 부른다.
				: 조상클래스 - 상위클래스, 부모클래스, 기반클래스
				: 자손클래스 - 하위클래스, 자식클래스, 파생클래스
			- 상속을 받을때는 멤버만 상속받는다.
			- 항상 자손클래스가 부모클래스보다 같거나 크다.
		2. 포함 (~~은 ~~을 포함하고 있다.) : has a 
			- 상속이외에 클래스를 재사용하는 방법.
			- 자손클래스의 멤버변수로 다른클래스를 선언하는 방법
			
		3. toString()
			- 인스턴스와 정보를 제공할 목적으로 사용된다.
			- 참조변수를 출력하면 참조변수가 가르키고 있는 인스턴스의 toString()를 호출한다.
		4. 단일상속 
			- 자바에서는 단일상속(두개이상불가)만 가능하다.
			- class TVCR extends TV, VCR{ //허용하지 않는다.
						}
			- Tv와 VCR에 동일한 메서드가 존재 한다면 어떤 메서드를 상속받는지 알수 없다.
			- Tv의 메서드 명을 변경한다면 그 동안 사용해온 모든 곳을 수정해주어야 한다.
			- 클래스 간의 관계가 명확하다.
		5. Object 클래스 : 모든 클래스의 최상위 클래스이다.
			- 다른 클래스를 상속받지 않는 클래스는 Object클래스를 상속받는다.
				class A extends Object{
				}
			- 모든 클래스는 Object 클래스를 상속받게 되어있다.
			- toString(), equals()를 사용할 수 있는 것은 Object클래스의 메서드 이기 때문이다.
		6. 오버라이딩 (overriding)	
			- 조상 클래스로 부터 상속받은 메서드의 내용을 재정의 하는 것.
			- 오버라이딩이 되기 위한 조건 : 선언부가 동일하면 된다.
				: 메서드명이 동일 
				: 메개변수의 갯수와 타입이 동일
				: 반환 타입이 동일
			- 부모클래스로부터 상속받는 자손클래스의 
				: 접근제어자는 부모보다 좁은 범위로 설정할 수 없다.
				: 예외의 갯수는 부모보다 많이 선언할 수 없다.
				제어자 void method() 예외처리 {
				}
		7. super
			- 조상클래스의 멤버와 자손클래스의 멤버가 중복정의되어 있을때 구분할 목적으로 사용된다.
			- 조상의 멤버와 자손의 멤버를 구분한다는 점을 제외하고는 this.과 동일 하다.
		8. super() : 조상 클래스의 생성자를 의미
			- this()와 마찬가지로 super()도 생성자 호출이다.
			- this()는 같은 클래스 내에서 다른 생성자를 호출 할 때 사용한다.
			- super() 자손클래스의 생성자 내에서 부모클래스의 생성자를 호출 할 때 사용한다.
			- this()와 super()은 둘다 첫줄이라 같이 사용 불가.
		9. 제어자 
			- 변수, 메서드 그리고 클래스의 선언부에 사용이 된다.
			- 접근 제어자와 그외 제어자가 나누어진다.
			- 접근 제어자
				: public, protected, default, private
			-그외 제어자
				: static, final, abstract, native, ........
			- 일반적으로 접근제어자를 가장 왼쪽에 사용한다.
				: private static final int a;
			- static (클래스의 , 공통적인)
			 	: 변수, 메서드, 초기화블럭에 사용할 수 없다.
			 	: 변수에 사용시
			 		1) 모든 인스턴스에서 공통적으로 사용
			 		2) 인스턴스의 생성없이 사용할 수 있다.
					3) 클래스가 Method Area에  로드될때 같이 생성된다.
					4) 클래스 멤버에서는 인스턴스멤버를 호출할 수 없다.
			- final(마지막의, 변경할 수 없는)
				: 변수에 사용시 값을 변경할 수 없는 상수가 된다.
				: 메서드에 사용시 오버라이드 할 수 없는 메서드가 된다.
				: 클래스에 사용시 상속할 수 없는 클래스가 된다.(부모클래스x)
			- abstract(추상의, 미완성의)
				: 메서드와 클래스에만 사용이 가능하다. (변수에서 사용 불가)
				: 메서드는 선언부와 구현부로 되어있지만 추상메서드는 선언부만 존재하고 구현부가 없다.
				: 추상메서드를 가지고 있다면 해당 클래스는 추상 클래스가 되어야 한다.	
				abstract class A{	
					abstract void method()
				}
				
		10. 접근제어자 
			- public
				: 접근 제한이 전혀 없다.
			- protected
				: 같은 패키지 내에서, 다른 패키지의 자손클래스에서 접근이 가능하다.
				: 클래스에는 사용할 수 없다.
			- default
				: 같은 패키지 내에서만 접근이 가능하다.
			- private
				: 같은 클래스 내에서만 접근이 가능하다.
				: 클래스에는 사용할 수 없다.
		11.캡슐화
			- 접근제어자를 사용하는 이유
				: 외부로 부터 데이터를 보호하기 위해 사용
				: 외부에는 불필요한 부분을 감출수 있다.
				: 
				
		12. 생성자의 접근제어자
			- 인스턴스의 생성을 제한할 수 있다.
			- 생성자의 접근 제어자를 private로 할 경우
				: 외부에서는 생성자에 접근할수 업스므로 인스턴스를 생성할 수 없다.
				: 다른 클래스의 조상이 될수 없다.
				: 다른클래스의 조상이 될 수 없으므로 final을 붙여 주어야 한다.
				
		13. 다형성 (Polymorphism)
			- 많은 형태를 가질수 있는 성질
			- 부모타입의 참조변수로 자식타입의 참조변수를 참조할 수 있다.
				
		14. 참조변수의 형 변환 		
			- 상속관계에서만 가능하다.
			- 자식타입 -> 부모타입 : up-casting, 캐스팅 연산자 생략 가능
			- 부모타입 -> 자식타입 : down-casting, 캐스팅 연산자 생략 불가능 
			- 업케스팅 후 다운케스팅은 가능 
			- 업케스팅 없이 바로다운케스팅은 안됨	
		
		15. instanceof 연산자
			- 참조변수가 참조하고 있는 인스턴스의 실제타입을 알아보기 위해 사용한다.
			- 연산결과가 true이면 검사한 타입으로 형변환이 가능하다.
			- 클래스 멤버는 참조변수의 타입에 영향을 받는다.
			- 참조변수의 타입에 영향을 받지 않는 것은 인스턴스 메서드 뿐이다.
		
		16. 매개변수의 다형성		
			- 참조변수의 다형적인 특징은 매개변수에도 적용된다.
		
		17. 여러개체배열, Vector	
			- 배열은 한번 크기를 정하면 변경할 수 없다. 이를 해결하기 위해 만들어졌다.
			- Vector 동적으로 크기가 관리되는 객체배열이다.	
				: Vector()   	 -> 10개의 객체를 저장할 수 있는 Vector 객체를 만든다.
				: add()      	 -> Vector에 객체를 추가한다.
				: remove()  	 -> Vector에서 객체를 삭제한다.
				: isEmpty() 	 -> Vector이 비어있는지 확인한다.
				: get(int index) -> index 번째 객체를 가져온다.
				: size()		 -> 저장된 객체의 수를 반환한다.
				
				
		18. 추상클래스(abstract)
			- 미완성된 클래스
				: 미완성된 메서드를 포함하고 있다.
			- 추상메서드
				: 미완성된 메서드이다.
				: 메서드는 선언부와 구현부로 이루어져있지만 추상메서드는 구현부가 없다.
			- 어떤 기능을 수행할 목적으로 만든것인지??
			
		19. 인터페이스(interface)
			- 일종의 추상클래스이지만 멤버변수로 
			- 작성방법 
				interface 인터페이스명{
					public static final 변수타입 변수명 = 값;
					public abstract 반환타입 메서드명(메게변수);
				}
			- 모든 변수는 public static final 이어야 한다. -> 생략 가능 
			- 모든 메서드는 public abstract 이어야한다. -> 생략가능
			- 인터페이스의 상속
				: 인터페이스는 클래스를 상속할 수 없다.
				  ->클래스를 상속받으면 인터페이스가 아니게 된다.
				: 인터페이스는 인터페이스를 다중상속할 수 있다.
			- 인터페이스의 구현
				: 자체로 객체를 생성할 수 없다.
				: 자신의 정이된 추상메서드의 몸통을 만들어주는 클래스가 존재해야한다.
				: 상속 -> extends  구현 -> implements
				: 인터페이스의 일부분만 구현하였다면 해당클래스는 추상클래스가 된다.
				: ~을 할수 있는 (~able)  
				: IMember => IMemberImpl
			- 인터페이스의 장점	
				: 개발시간을 단축 시킬수 있다.
				: 표준화가 가능하다.
				: 서로 관계가 없는 클래스들에게 관계를 설정해 줄수 있다.
				: 독립적인 프로그래밍이 가능하다.
			- 인터페이스의 이해
				: 클래스를 사용한 쪽(user)과 제공하는 쪽(provier)로 나눈다.
				: 메서드를 사용하는 쪽에서는 선언부만 알면된다.
				   A -I -B (직접관계 -> 간접관계)
				
				
				
				
		DTO : Data Table Object
			: 데이터의 전송을 위한 객체이며, 비지니스 로직까지 담아서 사용하기 한다.
		VO  : Variable Object 
			: 사용 되는 값이 객체로 표현 되며, 값 변경이 없는 경우를 말한다.


		 */
		}
}
